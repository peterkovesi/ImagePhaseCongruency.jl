<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function Reference · ImagePhaseCongruency</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../democards/gridtheme.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="ImagePhaseCongruency logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ImagePhaseCongruency</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">ImagePhaseCongruency</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>Function Reference</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Function Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Function Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/master/docs/src/functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Function-Reference"><a class="docs-heading-anchor" href="#Function-Reference">Function Reference</a><a id="Function-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Function-Reference" title="Permalink"></a></h1><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#ImagePhaseCongruency.bandpassfilter-Tuple{Tuple{Integer, Integer}, Real, Real, Integer}"><code>ImagePhaseCongruency.bandpassfilter</code></a></li><li><a href="#ImagePhaseCongruency.bandpassmonogenic-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{AbstractMatrix{T1}, Vector{T2}, Vector{T3}, Integer}} where {T1&lt;:Real, T2&lt;:Real, T3&lt;:Real}"><code>ImagePhaseCongruency.bandpassmonogenic</code></a></li><li><a href="#ImagePhaseCongruency.circsine"><code>ImagePhaseCongruency.circsine</code></a></li><li><a href="#ImagePhaseCongruency.cosineangularfilter-Union{Tuple{T2}, Tuple{T1}, Tuple{Real, Real, Matrix{T1}, Matrix{T2}}} where {T1&lt;:Real, T2&lt;:Real}"><code>ImagePhaseCongruency.cosineangularfilter</code></a></li><li><a href="#ImagePhaseCongruency.fillnan-Union{Tuple{AbstractArray{T, N}}, Tuple{T}, Tuple{N}} where {N, T}"><code>ImagePhaseCongruency.fillnan</code></a></li><li><a href="#ImagePhaseCongruency.filtergrid-Tuple{Integer, Integer}"><code>ImagePhaseCongruency.filtergrid</code></a></li><li><a href="#ImagePhaseCongruency.filtergrids-Tuple{Integer, Integer}"><code>ImagePhaseCongruency.filtergrids</code></a></li><li><a href="#ImagePhaseCongruency.gaborconvolve-Union{Tuple{T1}, Tuple{AbstractMatrix{T1}, Integer, Integer, Real, Real, Real, Real}, Tuple{AbstractMatrix{T1}, Integer, Integer, Real, Real, Real, Real, Integer}} where T1&lt;:Real"><code>ImagePhaseCongruency.gaborconvolve</code></a></li><li><a href="#ImagePhaseCongruency.gaussianangularfilter-Union{Tuple{T2}, Tuple{T1}, Tuple{Real, Real, Matrix{T1}, Matrix{T2}}} where {T1&lt;:Real, T2&lt;:Real}"><code>ImagePhaseCongruency.gaussianangularfilter</code></a></li><li><a href="#ImagePhaseCongruency.geoseries-Tuple{Real, Real, Integer}"><code>ImagePhaseCongruency.geoseries</code></a></li><li><a href="#ImagePhaseCongruency.gridangles-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{Matrix{T1}, Matrix{T2}, Matrix{T3}}} where {T1&lt;:Real, T2&lt;:Real, T3&lt;:Real}"><code>ImagePhaseCongruency.gridangles</code></a></li><li><a href="#ImagePhaseCongruency.highboostfilter-Tuple{Tuple{Integer, Integer}, Real, Integer, Real}"><code>ImagePhaseCongruency.highboostfilter</code></a></li><li><a href="#ImagePhaseCongruency.highpassfilter-Tuple{Tuple{Integer, Integer}, Real, Integer}"><code>ImagePhaseCongruency.highpassfilter</code></a></li><li><a href="#ImagePhaseCongruency.highpassmonogenic-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractMatrix{T1}, Vector{T2}, Integer}} where {T1&lt;:Real, T2&lt;:Real}"><code>ImagePhaseCongruency.highpassmonogenic</code></a></li><li><a href="#ImagePhaseCongruency.hysthresh-Union{Tuple{T0}, Tuple{AbstractMatrix{T0}, Real, Real}} where T0&lt;:Real"><code>ImagePhaseCongruency.hysthresh</code></a></li><li><a href="#ImagePhaseCongruency.loggabor-Tuple{Real, Real, Real}"><code>ImagePhaseCongruency.loggabor</code></a></li><li><a href="#ImagePhaseCongruency.lowpassfilter-Tuple{Tuple{Integer, Integer}, Real, Integer}"><code>ImagePhaseCongruency.lowpassfilter</code></a></li><li><a href="#ImagePhaseCongruency.monofilt-Union{Tuple{T1}, Tuple{AbstractMatrix{T1}, Integer, Real, Real, Real}, Tuple{AbstractMatrix{T1}, Integer, Real, Real, Real, Bool}} where T1&lt;:Real"><code>ImagePhaseCongruency.monofilt</code></a></li><li><a href="#ImagePhaseCongruency.monogenicfilters-Tuple{Integer, Integer}"><code>ImagePhaseCongruency.monogenicfilters</code></a></li><li><a href="#ImagePhaseCongruency.noiseonf-Tuple{Tuple{Integer, Integer}, Real}"><code>ImagePhaseCongruency.noiseonf</code></a></li><li><a href="#ImagePhaseCongruency.nophase-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Real"><code>ImagePhaseCongruency.nophase</code></a></li><li><a href="#ImagePhaseCongruency.packedmonogenicfilters-Tuple{Integer, Integer}"><code>ImagePhaseCongruency.packedmonogenicfilters</code></a></li><li><a href="#ImagePhaseCongruency.perfft2-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real"><code>ImagePhaseCongruency.perfft2</code></a></li><li><a href="#ImagePhaseCongruency.phasecong3-Union{Tuple{AbstractMatrix{T1}}, Tuple{T1}} where T1&lt;:Real"><code>ImagePhaseCongruency.phasecong3</code></a></li><li><a href="#ImagePhaseCongruency.phasecongmono-Union{Tuple{AbstractMatrix{T1}}, Tuple{T1}} where T1&lt;:Real"><code>ImagePhaseCongruency.phasecongmono</code></a></li><li><a href="#ImagePhaseCongruency.phasesym-Union{Tuple{AbstractMatrix{T1}}, Tuple{T1}} where T1&lt;:Real"><code>ImagePhaseCongruency.phasesym</code></a></li><li><a href="#ImagePhaseCongruency.phasesymmono-Union{Tuple{AbstractMatrix{T1}}, Tuple{T1}} where T1&lt;:Real"><code>ImagePhaseCongruency.phasesymmono</code></a></li><li><a href="#ImagePhaseCongruency.ppdenoise-Union{Tuple{AbstractMatrix{T1}}, Tuple{T1}} where T1&lt;:Real"><code>ImagePhaseCongruency.ppdenoise</code></a></li><li><a href="#ImagePhaseCongruency.ppdrc-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractMatrix{T1}, Vector{T2}}} where {T1&lt;:Real, T2&lt;:Real}"><code>ImagePhaseCongruency.ppdrc</code></a></li><li><a href="#ImagePhaseCongruency.quantizephase-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Integer}} where T&lt;:Real"><code>ImagePhaseCongruency.quantizephase</code></a></li><li><a href="#ImagePhaseCongruency.replacenan-Union{Tuple{AbstractArray{T, N}}, Tuple{T}, Tuple{N}, Tuple{AbstractArray{T, N}, Real}} where {N, T&lt;:AbstractFloat}"><code>ImagePhaseCongruency.replacenan</code></a></li><li><a href="#ImagePhaseCongruency.starsine"><code>ImagePhaseCongruency.starsine</code></a></li><li><a href="#ImagePhaseCongruency.step2line"><code>ImagePhaseCongruency.step2line</code></a></li><li><a href="#ImagePhaseCongruency.swapphase-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}}} where T&lt;:Real"><code>ImagePhaseCongruency.swapphase</code></a></li></ul><hr/><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.phasecongmono-Union{Tuple{AbstractMatrix{T1}}, Tuple{T1}} where T1&lt;:Real" href="#ImagePhaseCongruency.phasecongmono-Union{Tuple{AbstractMatrix{T1}}, Tuple{T1}} where T1&lt;:Real"><code>ImagePhaseCongruency.phasecongmono</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Phase congruency of an image using monogenic filters.</p><p>This code is considerably faster than <code>phasecong3()</code> but you may prefer the output from <code>phasecong3()</code>&#39;s oriented filters.</p><p>There are potentially many arguments, here is the full usage:</p><pre><code class="nohighlight hljs">  (PC, or, ft, T) =
          phasecongmono(img; nscale, minwavelength, mult,
                        sigmaonf, k, cutoff, g, deviationgain, noisemethod)

However, apart from the image, all parameters have defaults and the
usage can be as simple as:

   (PC,) = phasecongmono(img)   # Use (PC,) so that PC is not a tuple of all
                                # the returned values

More typically you will pass the image followed by a series of keyword
arguments that you wish to set, leaving the remaining parameters set to
their defaults, for example:

   (PC,) = phasecongmono(img, nscale = 5, minwavelength = 3, k = 2.5)

Keyword arguments:
             Default values      Description

   nscale           4    - Number of wavelet scales, try values 3-6
                           A lower value will reveal more fine scale
                           features. A larger value will highlight &#39;major&#39;
                           features.
   minwavelength    3    - Wavelength of smallest scale filter.
   mult             2.1  - Scaling factor between successive filters.
   sigmaonf         0.55 - Ratio of the standard deviation of the Gaussian
                           describing the log Gabor filter&#39;s transfer function
                           in the frequency domain to the filter center frequency.
   k                3.0  - No of standard deviations of the noise energy beyond
                           the mean at which we set the noise threshold point.
                           You may want to vary this up to a value of 10 or
                           20 for noisy images
   cutoff           0.5  - The fractional measure of frequency spread
                           below which phase congruency values get penalized.
   g                10   - Controls the sharpness of the transition in
                           the sigmoid function used to weight phase
                           congruency for frequency spread.
   deviationgain    1.5  - Amplification to apply to the calculated phase
                           deviation result. Increasing this sharpens the
                           edge responses, but can also attenuate their
                           magnitude if the gain is too large.  Sensible
                           values to use lie in the range 1-2.
   noisemethod      -1   - Parameter specifies method used to determine
                           noise statistics.
                             -1 use median of smallest scale filter responses
                             -2 use mode of smallest scale filter responses
                              0+ use noiseMethod value as the fixed noise threshold
                           A value of 0 will turn off all noise compensation.

Returned values:
   PC         - Phase congruency indicating edge significance
   or         - Orientation image in radians -pi/2 to pi/2,  +ve anticlockwise.
                0 corresponds to a vertical edge, pi/2 is horizontal.
   ft         - Local weighted mean phase angle at every point in the
                image.  A value of pi/2 corresponds to a bright line, 0
                corresponds to a step and -pi/2 is a dark line.
   T          - Calculated noise threshold (can be useful for
                diagnosing noise characteristics of images).  Once you know
                this you can then specify fixed thresholds and save some
                computation time.</code></pre><p>The convolutions are done via the FFT.  Many of the parameters relate to the specification of the filters in the frequency plane.  The values do not seem to be very critical and the defaults are usually fine.  You may want to experiment with the values of <code>nscales</code> and <code>k</code>, the noise compensation factor.</p><p>Typical sequence of operations to obtain an edge image:</p><pre><code class="nohighlight hljs"> &gt; (PC, or) = phasecongmono(img)
 &gt; nm = nonmaxsup(PC, or, 1.5)   # nonmaxima suppression
 &gt; bw = hysthresh(nm, 0.1, 0.3)  # hysteresis thresholding 0.1 - 0.3

Notes on filter settings to obtain even coverage of the spectrum
sigmaonf       .85   mult 1.3
sigmaonf       .75   mult 1.6     (filter bandwidth ~1 octave)
sigmaonf       .65   mult 2.1
sigmaonf       .55   mult 3       (filter bandwidth ~2 octaves)</code></pre><p>Note that better results are generally achieved using the large bandwidth filters.  I typically use a <code>sigmaOnf</code> value of 0.55 or even smaller.</p><p>See also:  <a href="#ImagePhaseCongruency.phasecong3-Union{Tuple{AbstractMatrix{T1}}, Tuple{T1}} where T1&lt;:Real"><code>phasecong3</code></a>, <a href="#ImagePhaseCongruency.phasesymmono-Union{Tuple{AbstractMatrix{T1}}, Tuple{T1}} where T1&lt;:Real"><code>phasesymmono</code></a>, <a href="#ImagePhaseCongruency.gaborconvolve-Union{Tuple{T1}, Tuple{AbstractMatrix{T1}, Integer, Integer, Real, Real, Real, Real}, Tuple{AbstractMatrix{T1}, Integer, Integer, Real, Real, Real, Real, Integer}} where T1&lt;:Real"><code>gaborconvolve</code></a>, <a href="#ImagePhaseCongruency.filtergrid-Tuple{Integer, Integer}"><code>filtergrid</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/phasecongruency.jl#L325-L417">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.ppdrc-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractMatrix{T1}, Vector{T2}}} where {T1&lt;:Real, T2&lt;:Real}" href="#ImagePhaseCongruency.ppdrc-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractMatrix{T1}, Vector{T2}}} where {T1&lt;:Real, T2&lt;:Real}"><code>ImagePhaseCongruency.ppdrc</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Phase Preserving Dynamic Range Compression</p><p>Generates a series of dynamic range compressed images at different scales. This function is designed to reveal subtle features within high dynamic range images such as aeromagnetic and other potential field grids. Often this kind of data is presented using histogram equalisation in conjunction with a rainbow colourmap. A problem with histogram equalisation is that the contrast amplification of a feature depends on how commonly its data value occurs, rather than on the amplitude of the feature itself.</p><p>Phase Preserving Dynamic Range Compression allows subtle features to be revealed without these distortions. Perceptually important phase information is preserved and the contrast amplification of anomalies in the signal is purely a function of their amplitude. It operates as follows: first a highpass filter is applied to the data, this controls the desired scale of analysis. The 2D analytic signal of the data is then computed to obtain local phase and amplitude at each point in the image. The amplitude is attenuated by adding 1 and then taking its logarithm, the signal is then reconstructed using the original phase values.</p><pre><code class="nohighlight hljs">Usage: dimg = ppdrc(img, wavelength; clip, n)

Arguments:     img - Image to be processed. A 2D array of Real or Gray elements.
        wavelength - Scalar value, or Vector, of wavelengths, in pixels, of
                     the cut-in frequencies to be used when forming the highpass
                     versions of the image.  Try a range of values starting
                     with, say, a wavelength corresponding to half the size
                     of the image and working down to something like 50
                     grid units.
Keyword arguments:
              clip - Percentage of output image histogram to clip.  Only a
                     very small value should be used, say 0.01 or 0.02, but
                     this can be beneficial.  Defaults to 0.01%
                 n - Order of the Butterworth high pass filter.  Defaults
                     to 2

Returns:      dimg - Array of the dynamic range reduced images.  If only
                     one wavelength is specified the image is returned
                     directly, and not as a one element array of image arrays.</code></pre><p>Important: Scaling of the image affects the results.  If your image has values of order 1 or less it is useful to scale the image up a few orders of magnitude. The reason is that when the frequency amplitudes are attenuated we add one before taking the log to avoid obtaining negative results for values less than one.  Thus if <code>v</code> is small <code>log(1 + v)</code> will not be a good approximation to <code>log(v)</code>. However, if you scale the image by say, 1000 then <code>log(1 + 1000*v)</code> will be a reasonable approximation to <code>log(1000*v)</code>.</p><p>When specifying the array <code>wavelength</code> it is suggested that you use wavelengths that increase in a geometric series.  You can use the function <code>geoseries()</code> to conveniently do this</p><p>Example using <code>geoseries()</code> to generate a set of wavelengths that increase geometrically in 10 steps from 50 to 800.</p><pre><code class="nohighlight hljs">   dimg = ppdrc(img, geoseries((50 800), 10))</code></pre><p>See also: <a href="#ImagePhaseCongruency.highpassmonogenic-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractMatrix{T1}, Vector{T2}, Integer}} where {T1&lt;:Real, T2&lt;:Real}"><code>highpassmonogenic</code></a>, <a href="#ImagePhaseCongruency.geoseries-Tuple{Real, Real, Integer}"><code>geoseries</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/phasecongruency.jl#L46-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.highpassmonogenic-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractMatrix{T1}, Vector{T2}, Integer}} where {T1&lt;:Real, T2&lt;:Real}" href="#ImagePhaseCongruency.highpassmonogenic-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractMatrix{T1}, Vector{T2}, Integer}} where {T1&lt;:Real, T2&lt;:Real}"><code>ImagePhaseCongruency.highpassmonogenic</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute phase and amplitude in highpass images via monogenic filters.</p><pre><code class="nohighlight hljs">Usage: (phase, orient, E) = highpassmonogenic(img, maxwavelength, n)

Arguments:           img - Image to be processed.  A 2D array of Real or Gray elements.
           maxwavelength - Wavelength(s) in pixels of the  cut-in frequency(ies)
                           of the Butterworth highpass filter.
                       n - The order of the Butterworth filter. This is an
                           integer &gt;= 1.  The higher the value the sharper
                           the cutoff.

Returns:           phase - The local phase. Values are between -pi/2 and pi/2
                  orient - The local orientation. Values between -pi and pi.
                           Note that where the local phase is close to
                           +-pi/2 the orientation will be poorly defined.
                       E - Local energy, or amplitude, of the signal.</code></pre><p>Note that <code>maxwavelength</code> can be an array in which case the outputs will be an array of output images of length <code>nscales</code>,  where <code>nscales = length(maxwavelength)</code>.</p><p>See also: <a href="#ImagePhaseCongruency.bandpassmonogenic-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{AbstractMatrix{T1}, Vector{T2}, Vector{T3}, Integer}} where {T1&lt;:Real, T2&lt;:Real, T3&lt;:Real}"><code>bandpassmonogenic</code></a>, <a href="#ImagePhaseCongruency.ppdrc-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractMatrix{T1}, Vector{T2}}} where {T1&lt;:Real, T2&lt;:Real}"><code>ppdrc</code></a>, <a href="#ImagePhaseCongruency.monofilt-Union{Tuple{T1}, Tuple{AbstractMatrix{T1}, Integer, Real, Real, Real}, Tuple{AbstractMatrix{T1}, Integer, Real, Real, Real, Bool}} where T1&lt;:Real"><code>monofilt</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/phasecongruency.jl#L166-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.bandpassmonogenic-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{AbstractMatrix{T1}, Vector{T2}, Vector{T3}, Integer}} where {T1&lt;:Real, T2&lt;:Real, T3&lt;:Real}" href="#ImagePhaseCongruency.bandpassmonogenic-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{AbstractMatrix{T1}, Vector{T2}, Vector{T3}, Integer}} where {T1&lt;:Real, T2&lt;:Real, T3&lt;:Real}"><code>ImagePhaseCongruency.bandpassmonogenic</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute phase and amplitude in bandpass images via monogenic filters.</p><pre><code class="nohighlight hljs">Usage: (phase, orient, E) = bandpassmonogenic(img, minwavelength, maxwavelength, n)

Arguments:           img - Image to be processed.  A 2D array of Real or Gray elements.
           minwavelength - } Wavelength(s) in pixels of the cut-in and cut-out frequency(ies)
           maxwavelength - } of the Butterworth bandpass filter(s).
                       n - The order of the Butterworth filter. This is an
                           integer &gt;= 1.  The higher the value the sharper
                           the cutoff.

Returns:           phase - The local phase. Values are between -pi/2 and pi/2
                  orient - The local orientation. Values between -pi and pi.
                           Note that where the local phase is close to
                           +-pi/2 the orientation will be poorly defined.
                       E - Local energy, or amplitude, of the signal.</code></pre><p>Note that <code>minwavelength</code> and <code>maxwavelength</code> can be (equal length) arrays in which case the outputs will be an array of output images of length <code>nscales</code>,  where <code>nscales = length(maxwavelength)</code>.</p><p>See also: <a href="#ImagePhaseCongruency.highpassmonogenic-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractMatrix{T1}, Vector{T2}, Integer}} where {T1&lt;:Real, T2&lt;:Real}"><code>highpassmonogenic</code></a>, <a href="#ImagePhaseCongruency.ppdrc-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractMatrix{T1}, Vector{T2}}} where {T1&lt;:Real, T2&lt;:Real}"><code>ppdrc</code></a>, <a href="#ImagePhaseCongruency.monofilt-Union{Tuple{T1}, Tuple{AbstractMatrix{T1}, Integer, Real, Real, Real}, Tuple{AbstractMatrix{T1}, Integer, Real, Real, Real, Bool}} where T1&lt;:Real"><code>monofilt</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/phasecongruency.jl#L243-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.phasesymmono-Union{Tuple{AbstractMatrix{T1}}, Tuple{T1}} where T1&lt;:Real" href="#ImagePhaseCongruency.phasesymmono-Union{Tuple{AbstractMatrix{T1}}, Tuple{T1}} where T1&lt;:Real"><code>ImagePhaseCongruency.phasesymmono</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Phase symmetry of an image using monogenic filters.</p><p>This function calculates the phase symmetry of points in an image. This is a contrast invariant measure of symmetry.  This function can be used as a line and blob detector.  The greyscale polarity of the lines that you want to find can be specified.</p><p>This code is considerably faster than <code>phasesym()</code> but you may prefer the output from <code>phasesym()</code>&#39;s oriented filters.</p><p>There are potentially many arguments, here is the full usage:</p><pre><code class="nohighlight hljs">  (phSym, symmetryEnergy, T) =
               phasesymmono(img; nscale, minwaveLength, mult,
                            sigmaonf, k, polarity, noisemethod)</code></pre><p>However, apart from the image, all parameters have defaults and the usage can be as simple as:</p><pre><code class="nohighlight hljs">   (phSym,) = phasesymmono(img)

Keyword arguments:
             Default values      Description

   nscale           5    - Number of wavelet scales, try values 3-6
   minwaveLength    3    - Wavelength of smallest scale filter.
   mult             2.1  - Scaling factor between successive filters.
   sigmaonf         0.55 - Ratio of the standard deviation of the Gaussian
                           describing the log Gabor filter&#39;s transfer function
                           in the frequency domain to the filter center frequency.
   k                2.0  - No of standard deviations of the noise energy beyond
                           the mean at which we set the noise threshold point.
                           You may want to vary this up to a value of 10 or
                           20 for noisy images
   polarity         0    - Controls &#39;polarity&#39; of symmetry features to find.
                            1 - just return &#39;bright&#39; points
                           -1 - just return &#39;dark&#39; points
                            0 - return bright and dark points.
   noisemethod      -1   - Parameter specifies method used to determine
                           noise statistics.
                             -1 use median of smallest scale filter responses
                             -2 use mode of smallest scale filter responses
                              0+ use noiseMethod value as the fixed noise threshold
                           A value of 0 will turn off all noise compensation.

Return values:
   phSym                 - Phase symmetry image (values between 0 and 1).
   symmetryEnergy        - Un-normalised raw symmetry energy which may be
                           more to your liking.
   T                     - Calculated noise threshold (can be useful for
                           diagnosing noise characteristics of images)</code></pre><p>The convolutions are done via the FFT.  Many of the parameters relate to the specification of the filters in the frequency plane.  The values do not seem to be very critical and the defaults are usually fine.  You may want to experiment with the values of <code>nscales</code> and <code>k</code>, the noise compensation factor.</p><p>Notes on filter settings to obtain even coverage of the spectrum</p><pre><code class="nohighlight hljs">sigmaonf       .85   mult 1.3
sigmaonf       .75   mult 1.6     (filter bandwidth ~1 octave)
sigmaonf       .65   mult 2.1
sigmaonf       .55   mult 3       (filter bandwidth ~2 octaves)</code></pre><p>See Also:  <a href="#ImagePhaseCongruency.phasesym-Union{Tuple{AbstractMatrix{T1}}, Tuple{T1}} where T1&lt;:Real"><code>phasesym</code></a>, <a href="#ImagePhaseCongruency.phasecongmono-Union{Tuple{AbstractMatrix{T1}}, Tuple{T1}} where T1&lt;:Real"><code>phasecongmono</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/phasecongruency.jl#L657-L724">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.monofilt-Union{Tuple{T1}, Tuple{AbstractMatrix{T1}, Integer, Real, Real, Real}, Tuple{AbstractMatrix{T1}, Integer, Real, Real, Real, Bool}} where T1&lt;:Real" href="#ImagePhaseCongruency.monofilt-Union{Tuple{T1}, Tuple{AbstractMatrix{T1}, Integer, Real, Real, Real}, Tuple{AbstractMatrix{T1}, Integer, Real, Real, Real, Bool}} where T1&lt;:Real"><code>ImagePhaseCongruency.monofilt</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apply monogenic filters to an image to obtain 2D analytic signal.</p><p>This is an implementation of Felsberg&#39;s monogenic filters</p><pre><code class="nohighlight hljs">Usage: (f, h1f, h2f, A, theta, psi) =
            monofilt(img, nscale, minWaveLength, mult, sigmaOnf, orientWrap)
                             3         4           2     0.65    true/false
Arguments:
The convolutions are done via the FFT.  Many of the parameters relate
to the specification of the filters in the frequency plane.

  Variable       Suggested   Description
  name           value
 ----------------------------------------------------------
   img                       Image to be convolved. An Array of Real or Gray.
   nscale          = 3       Number of filter scales.
   minWaveLength   = 4       Wavelength of smallest scale filter.
   mult            = 2       Scaling factor between successive filters.
   sigmaonf        = 0.65    Ratio of the standard deviation of the
                             Gaussian describing the log Gabor filter&#39;s
                             transfer function in the frequency domain
                             to the filter center frequency.
   orientWrap       false    Optional Boolean flag  to turn on/off
                             &#39;wrapping&#39; of orientation data from a
                             range of -pi .. pi to the range 0 .. pi.
                             This affects the interpretation of the
                             phase angle - see note below. Defaults to false.
Returns:
       f  - vector of bandpass filter responses with respect to scale.
     h1f  - vector of bandpass h1 filter responses wrt scale.
     h2f  - vector of bandpass h2 filter responses.
       A  - vector of monogenic energy responses.
   theta  - vector of phase orientation responses.
     psi  - vector of phase angle responses.</code></pre><p>If <code>orientWrap</code> is true <code>theta</code> will be returned in the range <code>0 .. pi</code></p><p>Experimentation with <code>sigmaonf</code> can be useful depending on your application. I have found values as low as 0.2 (a filter with a <em>very</em> large bandwidth) to be useful on some occasions.</p><p>See also: <a href="#ImagePhaseCongruency.gaborconvolve-Union{Tuple{T1}, Tuple{AbstractMatrix{T1}, Integer, Integer, Real, Real, Real, Real}, Tuple{AbstractMatrix{T1}, Integer, Integer, Real, Real, Real, Real, Integer}} where T1&lt;:Real"><code>gaborconvolve</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/phasecongruency.jl#L883-L926">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.gaborconvolve-Union{Tuple{T1}, Tuple{AbstractMatrix{T1}, Integer, Integer, Real, Real, Real, Real}, Tuple{AbstractMatrix{T1}, Integer, Integer, Real, Real, Real, Real, Integer}} where T1&lt;:Real" href="#ImagePhaseCongruency.gaborconvolve-Union{Tuple{T1}, Tuple{AbstractMatrix{T1}, Integer, Integer, Real, Real, Real, Real}, Tuple{AbstractMatrix{T1}, Integer, Integer, Real, Real, Real, Real, Integer}} where T1&lt;:Real"><code>ImagePhaseCongruency.gaborconvolve</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convolve an image with a bank of log-Gabor filters.</p><pre><code class="nohighlight hljs">Usage: (EO, BP) = gaborconvolve(img,  nscale, norient, minWaveLength, mult,
                                 sigmaOnf, dThetaOnSigma, Lnorm)

Arguments:
The convolutions are done via the FFT.  Many of the parameters relate
to the specification of the filters in the frequency plane.

  Variable       Suggested   Description
  name           value
 ----------------------------------------------------------
   img                       Image to be convolved.
   nscale          = 4       Number of wavelet scales.
   norient         = 6       Number of filter orientations.
   minWaveLength   = 3       Wavelength of smallest scale filter.
   mult            = 1.7     Scaling factor between successive filters.
   sigmaOnf        = 0.65    Ratio of the standard deviation of the
                             Gaussian describing the log Gabor filter&#39;s
                             transfer function in the frequency domain
                             to the filter center frequency.
   dThetaOnSigma   = 1.3     Ratio of angular interval between filter
                             orientations and the standard deviation of
                             the angular Gaussian function used to
                             construct filters in the freq. plane.
   Lnorm            0        Optional integer indicating what norm the
                             filters should be normalized to.  A value of 1
                             will produce filters with the same L1 norm, 2
                             will produce filters with matching L2
                             norm. the default value of 0 results in no
                             normalization (the filters have unit height
                             Gaussian transfer functions on a log frequency
                             scale)
Returns:

  EO - 2D array of arrays of complex valued convolution results
       EO[s,o] = convolution result for scale s and orientation o.
       The real part is the result of convolving with the even
       symmetric filter, the imaginary part is the result from
       convolution with the odd symmetric filter.

       Hence:
       abs.(EO[s,o]) returns the magnitude of the convolution over the
                    image at scale s and orientation o.
       angle.(EO[s,o]) returns the phase angles.

  BP - Array of bandpass images corresponding to each scale s.</code></pre><p>Notes on filter settings to obtain even coverage of the spectrum energy</p><pre><code class="nohighlight hljs">dThetaOnSigma 1.2 - 1.3
sigmaOnf  .90   mult 1.15
sigmaOnf  .85   mult 1.2
sigmaOnf  .75   mult 1.4       (bandwidth ~1 octave)
sigmaOnf  .65   mult 1.7
sigmaOnf  .55   mult 2.2       (bandwidth ~2 octaves)</code></pre><p>The determination of <code>mult</code> given <code>sigmaOnf</code> is entirely empirical.  What I do is plot out the sum of the squared filter amplitudes in the frequency domain and see how even the coverage of the spectrum is.  If there are concentric &#39;gaps&#39; in the spectrum one needs to reduce mult and/or reduce <code>sigmaOnf</code> (which increases filter bandwidth)</p><p>If there are &#39;gaps&#39; radiating outwards then one needs to reduce <code>dthetaOnSigma</code> (increasing angular bandwidth of the filters)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/phasecongruency.jl#L1002-L1069">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.phasecong3-Union{Tuple{AbstractMatrix{T1}}, Tuple{T1}} where T1&lt;:Real" href="#ImagePhaseCongruency.phasecong3-Union{Tuple{AbstractMatrix{T1}}, Tuple{T1}} where T1&lt;:Real"><code>ImagePhaseCongruency.phasecong3</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Computes edge and corner phase congruency in an image via log-Gabor filters.</p><p>There are potentially many arguments, here is the full usage:</p><pre><code class="nohighlight hljs">  (M, m, or, ft, EO, T) = phasecong3(img; nscale, norient, minwavelength,
                          mult, sigmaonf, k, cutoff, g, noisemethod)</code></pre><p>However, apart from the image, all parameters have defaults and the usage can be as simple as:</p><pre><code class="nohighlight hljs">    (M,) = phasecong3(img)

Keyword Arguments:
             Default values      Description

   nscale           4    - Number of wavelet scales, try values 3-6
   norient          6    - Number of filter orientations.
   minwavelength    3    - Wavelength of smallest scale filter.
   mult             2.1  - Scaling factor between successive filters.
   sigmaonf         0.55 - Ratio of the standard deviation of the Gaussian
                           describing the log Gabor filter&#39;s transfer function
                           in the frequency domain to the filter center frequency.
   k                2.0  - No of standard deviations of the noise energy beyond
                           the mean at which we set the noise threshold point.
                           You may want to vary this up to a value of 10 or
                           20 for noisy images
   cutoff           0.5  - The fractional measure of frequency spread
                           below which phase congruency values get penalized.
   g                10   - Controls the sharpness of the transition in
                           the sigmoid function used to weight phase
                           congruency for frequency spread.
   noisemethod      -1   - Parameter specifies method used to determine
                           noise statistics.
                             -1 use median of smallest scale filter responses
                             -2 use mode of smallest scale filter responses
                              0+ use noisemethod value as the fixed noise threshold

Returned values:
   M          - Maximum moment of phase congruency covariance.
                This is used as a indicator of edge strength.
   m          - Minimum moment of phase congruency covariance.
                This is used as a indicator of corner strength.
   or         - Orientation image in radians -pi/2 to pi/2,  +ve anticlockwise.
                0 corresponds to a vertical edge, pi/2 is horizontal.
   ft         - Local weighted mean phase angle at every point in the
                image.  A value of pi/2 corresponds to a bright line, 0
                corresponds to a step and -pi/2 is a dark line.
   EO         - A 2D array of complex valued convolution results for each scale
                and orientation
   T          - Calculated noise threshold (can be useful for
                diagnosing noise characteristics of images).  Once you know
                this you can then specify fixed thresholds and save some
                computation time.</code></pre><p><code>EO[s,o]</code> = convolution result for scale <code>s</code> and orientation <code>o</code>.  The real part is the result of convolving with the even symmetric filter, the imaginary part is the result from convolution with the odd symmetric filter.</p><p>Hence:       <code>abs.(EO[s,o])</code> returns the magnitude of the convolution over the       image at scale <code>s</code> and orientation <code>o</code>,       <code>angle.(EO[s,o])</code> returns the phase angles.</p><p>The convolutions are done via the FFT.  Many of the parameters relate to the specification of the filters in the frequency plane.  The values do not seem to be very critical and the defaults are usually fine.  You may want to experiment with the values of <code>nscales</code> and <code>k</code>, the noise compensation factor.</p><p>Some filter parameters to obtain even coverage of the spectrum</p><pre><code class="nohighlight hljs">sigmaonf       .85   mult 1.3
sigmaonf       .75   mult 1.6     (filter bandwidth ~1 octave)
sigmaonf       .65   mult 2.1
sigmaonf       .55   mult 3       (filter bandwidth ~2 octaves)</code></pre><p>See also:  <a href="#ImagePhaseCongruency.phasesym-Union{Tuple{AbstractMatrix{T1}}, Tuple{T1}} where T1&lt;:Real"><code>phasesym</code></a>, <a href="#ImagePhaseCongruency.gaborconvolve-Union{Tuple{T1}, Tuple{AbstractMatrix{T1}, Integer, Integer, Real, Real, Real, Real}, Tuple{AbstractMatrix{T1}, Integer, Integer, Real, Real, Real, Real, Integer}} where T1&lt;:Real"><code>gaborconvolve</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/phasecongruency.jl#L1175-L1253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.phasesym-Union{Tuple{AbstractMatrix{T1}}, Tuple{T1}} where T1&lt;:Real" href="#ImagePhaseCongruency.phasesym-Union{Tuple{AbstractMatrix{T1}}, Tuple{T1}} where T1&lt;:Real"><code>ImagePhaseCongruency.phasesym</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute phase symmetry on an image via log-Gabor filters.</p><p>This function calculates the phase symmetry of points in an image. This is a contrast invariant measure of symmetry.  This function can be used as a line and blob detector.  The greyscale polarity of the lines that you want to find can be specified.</p><pre><code class="nohighlight hljs">Usage:   (phSym, orientation, totalEnergy, T) =
                phasesym(img; nscale = 5, norient = 6, minwavelength = 3, mult = 2.1,
                         sigmaonf = 0.55, k = 2, polarity = 0, noisemethod = -1)

However, apart from the image, all parameters have defaults and the
usage can be as simple as:

    (phSym,) = phasesym(img)

Argument:
                    img  - Image to be processed. 2D Array of Real or Gray

Keyword Arguments:
              Default values      Description
    nscale           5    - Number of wavelet scales, try values 3-6
    norient          6    - Number of filter orientations.
    minwavelength    3    - Wavelength of smallest scale filter.
    mult             2.1  - Scaling factor between successive filters.
    sigmaonf         0.55 - Ratio of the standard deviation of the Gaussian
                            describing the log Gabor filter&#39;s transfer function
                            in the frequency domain to the filter center frequency.
    k                2.0  - No of standard deviations of the noise energy beyond
                            the mean at which we set the noise threshold point.
                            You may want to vary this up to a value of 10 or
                            20 for noisy images
    polarity         0    - Controls &#39;polarity&#39; of symmetry features to find.
                             1 - just return &#39;bright&#39; points
                            -1 - just return &#39;dark&#39; points
                             0 - return bright and dark points.
    noisemethod      -1   - Parameter specifies method used to determine
                            noise statistics.
                              -1 use median of smallest scale filter responses
                              -2 use mode of smallest scale filter responses
                               0+ use noiseMethod value as the fixed noise threshold.

Return values:
    phSym                 - Phase symmetry image (values between 0 and 1).
    orientation           - Orientation image. Orientation in which local
                            symmetry energy is a maximum, in radians
                            (-pi/2 - pi/2), angles positive anti-clockwise. Note
                            the orientation info is quantized by the number
                            of orientations
    totalEnergy           - Un-normalised raw symmetry energy which may be
                            more to your liking.
    T                     - Calculated noise threshold (can be useful for
                            diagnosing noise characteristics of images).  Once you know
                            this you can then specify fixed thresholds and save some
                            computation time.</code></pre><p>The convolutions are done via the FFT.  Many of the parameters relate to the specification of the filters in the frequency plane.  The values do not seem to be very critical and the defaults are usually fine.  You may want to experiment with the values of <code>nscales</code> and <code>k</code>, the noise compensation factor.</p><p>Notes on filter settings to obtain even coverage of the spectrum</p><pre><code class="nohighlight hljs">sigmaonf       .85   mult 1.3
sigmaonf       .75   mult 1.6     (filter bandwidth ~1 octave)
sigmaonf       .65   mult 2.1
sigmaonf       .55   mult 3       (filter bandwidth ~2 octaves)</code></pre><p>See also:  <a href="#ImagePhaseCongruency.phasesymmono-Union{Tuple{AbstractMatrix{T1}}, Tuple{T1}} where T1&lt;:Real"><code>phasesymmono</code></a>, <a href="#ImagePhaseCongruency.phasecong3-Union{Tuple{AbstractMatrix{T1}}, Tuple{T1}} where T1&lt;:Real"><code>phasecong3</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/phasecongruency.jl#L1510-L1582">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.ppdenoise-Union{Tuple{AbstractMatrix{T1}}, Tuple{T1}} where T1&lt;:Real" href="#ImagePhaseCongruency.ppdenoise-Union{Tuple{AbstractMatrix{T1}}, Tuple{T1}} where T1&lt;:Real"><code>ImagePhaseCongruency.ppdenoise</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Phase preserving wavelet image denoising.</p><pre><code class="nohighlight hljs">Usage: cleanimage = ppdenoise(img,  nscale = 5, norient = 6,
                              mult = 2.5, minwavelength = 2, sigmaonf = 0.55,
                              dthetaonsigma = 1.0, k = 3, softness = 1.0)
Argument:
          img - Image to be processed (greyscale)

Keyword arguments:
        nscale - No of filter scales to use (5-7) - the more scales used
                 the more low frequencies are covered.
       norient - No of orientations to use (6)
          mult - Multiplying factor between successive scales  (2.5-3)
 minwavelength - Wavelength of smallest scale filter (2)
      sigmaonf - Ratio of the standard deviation of the Gaussian
                 describing the log Gabor filter&#39;s transfer function
                 in the frequency domain to the filter center frequency (0.55)
 dthetaonsigma - Ratio of angular interval between filter orientations
                 and the standard deviation of the angular Gaussian (1)
                 function used to construct filters in the freq. plane.
             k - No of standard deviations of noise to reject 2-3
      softness - Degree of soft thresholding (0-hard to 1-soft)</code></pre><p>The convolutions are done via the FFT.  Many of the parameters relate to the specification of the filters in the frequency plane.  Most arguments do not need to be changed from the defaults and are mostly not that critical.  The main parameter that you may wish to play with is <code>k</code>, the number of standard deviations of noise to reject.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/phasecongruency.jl#L1778-L1810">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.filtergrids-Tuple{Integer, Integer}" href="#ImagePhaseCongruency.filtergrids-Tuple{Integer, Integer}"><code>ImagePhaseCongruency.filtergrids</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Generate grids for constructing frequency domain filters.</p><pre><code class="nohighlight hljs">Usage:  (f, fx, fy) = filtergrids(rows, cols)
        (f, fx, fy) = filtergrids((rows, cols))

Arguments:  rows, cols - Size of image/filter

Returns:             f - Grid of size (rows, cols) containing frequency
                         values from 0 to 0.5,  where f =
                         sqrt(fx^2 + fy^2). The grid is quadrant
                         shifted so that 0 frequency is at f[1,1]

                fx, fy - Grids containing normalised frequency values
                         ranging from -0.5 to 0.5 in x and y directions
                         respectively. fx and fy are quadrant shifted.</code></pre><p>See also: <a href="#ImagePhaseCongruency.filtergrid-Tuple{Integer, Integer}"><code>filtergrid</code></a>  where you are only needing radius</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/frequencyfilt.jl#L45-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.filtergrid-Tuple{Integer, Integer}" href="#ImagePhaseCongruency.filtergrid-Tuple{Integer, Integer}"><code>ImagePhaseCongruency.filtergrid</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Generate grid for constructing frequency domain filters.</p><pre><code class="nohighlight hljs">Usage:  f = filtergrid(rows, cols)
        f = filtergrid((rows, cols))

Arguments:  rows, cols - Size of image/filter

Returns:             f - Grid of size (rows, cols) containing normalised
                         frequency values from 0 to 0.5.  Grid is quadrant
                         shifted so that 0 frequency is at f[1,1]
</code></pre><p>Used by <a href="#ImagePhaseCongruency.phasecongmono-Union{Tuple{AbstractMatrix{T1}}, Tuple{T1}} where T1&lt;:Real"><code>phasecongmono</code></a>, <a href="#ImagePhaseCongruency.phasecong3-Union{Tuple{AbstractMatrix{T1}}, Tuple{T1}} where T1&lt;:Real"><code>phasecong3</code></a>, etc etc</p><p>See also: <a href="#ImagePhaseCongruency.filtergrids-Tuple{Integer, Integer}"><code>filtergrids</code></a>   if you also want normalized frequency grids in           the x and y directions as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/frequencyfilt.jl#L105-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.monogenicfilters-Tuple{Integer, Integer}" href="#ImagePhaseCongruency.monogenicfilters-Tuple{Integer, Integer}"><code>ImagePhaseCongruency.monogenicfilters</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Generate monogenic filter grids.</p><pre><code class="nohighlight hljs">Usage: (H1, H2, f) = monogenicfilters(rows, cols)
       (H1, H2, f) = monogenicfilters((rows, cols))

Arguments:  rows,cols - Size of filters to generate

Returns: H1, H2 - The two monogenic filters.
              f - Frequency grid corresponding to the filters.

where:
       H1 = i*fx./f
       H2 = i*fy./f
</code></pre><p>Note that H1, H2, and f and quadrant shifted to that the 0 frequency value is at coordinate [1,1].</p><p>See also: <a href="#ImagePhaseCongruency.packedmonogenicfilters-Tuple{Integer, Integer}"><code>packedmonogenicfilters</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/frequencyfilt.jl#L154-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.packedmonogenicfilters-Tuple{Integer, Integer}" href="#ImagePhaseCongruency.packedmonogenicfilters-Tuple{Integer, Integer}"><code>ImagePhaseCongruency.packedmonogenicfilters</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Monogenic filter where both filters are packed in the one Complex grid.</p><pre><code class="nohighlight hljs">Usage: (H, f) = packedmonogenicfilters(rows, cols)
       (H, f) = packedmonogenicfilters((rows, cols))

Arguments:  rows,cols - Size of filters to generate

Returns:      H - The two monogenic filters packed into the
                  one Complex64 grid.
              f - Frequency grid corresponding to the filter.</code></pre><p>The two monogenic filters are defined as</p><pre><code class="nohighlight hljs">       H1 = i*fx./f
       H2 = i*fy./f</code></pre><p>However the two filters can be packed together as a complex valued matrix, one in the real part and one in the imaginary part.  Do this by multiplying H2 by i and then adding it to H1.  When the convolution is performed via the fft the real part of the result will correspond to the convolution with H1 and the imaginary part with H2.  This allows the two convolutions to be done as one in the frequency domain, saving time and memory.</p><p>Note that H and f and quadrant shifted to that the 0 frequency value is at coordinate [1,1].</p><p>See also: <a href="#ImagePhaseCongruency.monogenicfilters-Tuple{Integer, Integer}"><code>monogenicfilters</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/frequencyfilt.jl#L198-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.lowpassfilter-Tuple{Tuple{Integer, Integer}, Real, Integer}" href="#ImagePhaseCongruency.lowpassfilter-Tuple{Tuple{Integer, Integer}, Real, Integer}"><code>ImagePhaseCongruency.lowpassfilter</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct a low-pass Butterworth filter.</p><pre><code class="nohighlight hljs">Usage: f = lowpassfilter(sze, cutoff, n)

where: sze    is a two element tuple specifying the size of filter
              to construct (rows, cols).
       cutoff is the cutoff frequency of the filter 0 - 0.5
       n      is the order of the filter, the higher n is the sharper
              the transition is. (n must be an integer &gt;= 1).
              Note that n is doubled so that it is always an even integer.

                      1
      f =    --------------------
                              2n
              1.0 + (w/cutoff)</code></pre><p>The frequency origin of the returned filter is at the corners.</p><p>See also: <a href="#ImagePhaseCongruency.highpassfilter-Tuple{Tuple{Integer, Integer}, Real, Integer}"><code>highpassfilter</code></a>, <a href="#ImagePhaseCongruency.highboostfilter-Tuple{Tuple{Integer, Integer}, Real, Integer, Real}"><code>highboostfilter</code></a>, <a href="#ImagePhaseCongruency.bandpassfilter-Tuple{Tuple{Integer, Integer}, Real, Real, Integer}"><code>bandpassfilter</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/frequencyfilt.jl#L252-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.bandpassfilter-Tuple{Tuple{Integer, Integer}, Real, Real, Integer}" href="#ImagePhaseCongruency.bandpassfilter-Tuple{Tuple{Integer, Integer}, Real, Real, Integer}"><code>ImagePhaseCongruency.bandpassfilter</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct a band-pass Butterworth filter.</p><pre><code class="nohighlight hljs">Usage: f = bandpassfilter(sze, cutin, cutoff, n)

Arguments:
             sze - A 2 element tuple specifying the size of filter
                   to construct (rows, cols).
   cutin, cutoff - The frequencies defining the band pass 0 - 0.5
               n - The order of the filter, the higher n is the sharper
                   the transition is. (n must be an integer &gt;= 1).
Returns:
               f - Frequency domain filter of size==sze, the frequency
                   origin is at the corners.</code></pre><p>See also: <a href="#ImagePhaseCongruency.lowpassfilter-Tuple{Tuple{Integer, Integer}, Real, Integer}"><code>lowpassfilter</code></a>, <a href="#ImagePhaseCongruency.highpassfilter-Tuple{Tuple{Integer, Integer}, Real, Integer}"><code>highpassfilter</code></a>, <a href="#ImagePhaseCongruency.highboostfilter-Tuple{Tuple{Integer, Integer}, Real, Integer, Real}"><code>highboostfilter</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/frequencyfilt.jl#L289-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.highboostfilter-Tuple{Tuple{Integer, Integer}, Real, Integer, Real}" href="#ImagePhaseCongruency.highboostfilter-Tuple{Tuple{Integer, Integer}, Real, Integer, Real}"><code>ImagePhaseCongruency.highboostfilter</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct a high-boost Butterworth filter.</p><pre><code class="nohighlight hljs">Usage: f = highboostfilter(sze, cutoff, n, boost)

Arguments:
         sze - A 2 element tuple specifying the size of filter
               to construct (rows, cols).
      cutoff - The cutoff frequency of the filter 0 - 0.5
           n - The order of the filter, the higher n is the sharper
               the transition is. (n must be an integer &gt;= 1).
       boost - The ratio that high frequency values are boosted
               relative to the low frequency values.  If boost is less
               than one then a &#39;lowboost&#39; filter is generated
Returns:
           f - Frequency domain filter of size==sze, the frequency
               origin is at the corners.</code></pre><p>See also: <a href="#ImagePhaseCongruency.lowpassfilter-Tuple{Tuple{Integer, Integer}, Real, Integer}"><code>lowpassfilter</code></a>, <a href="#ImagePhaseCongruency.highpassfilter-Tuple{Tuple{Integer, Integer}, Real, Integer}"><code>highpassfilter</code></a>, <a href="#ImagePhaseCongruency.bandpassfilter-Tuple{Tuple{Integer, Integer}, Real, Real, Integer}"><code>bandpassfilter</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/frequencyfilt.jl#L321-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.highpassfilter-Tuple{Tuple{Integer, Integer}, Real, Integer}" href="#ImagePhaseCongruency.highpassfilter-Tuple{Tuple{Integer, Integer}, Real, Integer}"><code>ImagePhaseCongruency.highpassfilter</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct a high-pass Butterworth filter.</p><pre><code class="nohighlight hljs">Usage: f = highpassfilter(sze, cutoff, n)

         sze - A 2 element tuple specifying the size of filter
               to construct (rows, cols).
      cutoff - The cutoff frequency of the filter 0 - 0.5
           n - The order of the filter, the higher n is the sharper
               the transition is. (n must be an integer &gt;= 1).
Returns:
           f - Frequency domain filter of size==sze, the frequency
               origin is at the corners.</code></pre><p>See also: <a href="#ImagePhaseCongruency.lowpassfilter-Tuple{Tuple{Integer, Integer}, Real, Integer}"><code>lowpassfilter</code></a>, <a href="#ImagePhaseCongruency.highboostfilter-Tuple{Tuple{Integer, Integer}, Real, Integer, Real}"><code>highboostfilter</code></a>, <a href="#ImagePhaseCongruency.bandpassfilter-Tuple{Tuple{Integer, Integer}, Real, Real, Integer}"><code>bandpassfilter</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/frequencyfilt.jl#L358-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.loggabor-Tuple{Real, Real, Real}" href="#ImagePhaseCongruency.loggabor-Tuple{Real, Real, Real}"><code>ImagePhaseCongruency.loggabor</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The logarithmic Gabor function in the frequency domain.</p><pre><code class="nohighlight hljs">Usage: v = loggabor(f::Real, fo::Real, sigmaOnf::Real)

Arguments:
            f - Frequency to evaluate the function at.
           fo - Centre frequency of filter.
     sigmaOnf - Ratio of the standard deviation of the Gaussian
                describing the log Gabor filter&#39;s transfer function
                in the frequency domain to the filter center frequency.

sigmaOnf = 0.75 gives a filter bandwidth of about 1 octave.
sigmaOnf = 0.55 gives a filter bandwidth of about 2 octaves.
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/frequencyfilt.jl#L384-L401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.gridangles-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{Matrix{T1}, Matrix{T2}, Matrix{T3}}} where {T1&lt;:Real, T2&lt;:Real, T3&lt;:Real}" href="#ImagePhaseCongruency.gridangles-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{Matrix{T1}, Matrix{T2}, Matrix{T3}}} where {T1&lt;:Real, T2&lt;:Real, T3&lt;:Real}"><code>ImagePhaseCongruency.gridangles</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Generate arrays of filter grid angles.</p><pre><code class="nohighlight hljs">Usage: (sintheta, costheta) = gridangles(freq, fx, fy)

Arguments: freq, fx, fy - The output of filtergrids()

Returns:       sintheta - The sine and cosine of the angles in the filtergrid
               costheta
</code></pre><p>See also <a href="#ImagePhaseCongruency.filtergrids-Tuple{Integer, Integer}"><code>filtergrids</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/frequencyfilt.jl#L412-L425">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.cosineangularfilter-Union{Tuple{T2}, Tuple{T1}, Tuple{Real, Real, Matrix{T1}, Matrix{T2}}} where {T1&lt;:Real, T2&lt;:Real}" href="#ImagePhaseCongruency.cosineangularfilter-Union{Tuple{T2}, Tuple{T1}, Tuple{Real, Real, Matrix{T1}, Matrix{T2}}} where {T1&lt;:Real, T2&lt;:Real}"><code>ImagePhaseCongruency.cosineangularfilter</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Orientation selective frequency domain filter with cosine windowing function.</p><pre><code class="nohighlight hljs">Usage: filter = cosineangularfilter(angl, wavelen, sintheta, costheta)

Arguments:
               angl - Orientation of the filter (radians)
            wavelen - Wavelength of the angular cosine window function.
 sintheta, costheta - Grids as returned by gridangles()</code></pre><p>See also: <a href="#ImagePhaseCongruency.gaussianangularfilter-Union{Tuple{T2}, Tuple{T1}, Tuple{Real, Real, Matrix{T1}, Matrix{T2}}} where {T1&lt;:Real, T2&lt;:Real}"><code>gaussianangularfilter</code></a>, <a href="#ImagePhaseCongruency.filtergrids-Tuple{Integer, Integer}"><code>filtergrids</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/frequencyfilt.jl#L439-L451">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.gaussianangularfilter-Union{Tuple{T2}, Tuple{T1}, Tuple{Real, Real, Matrix{T1}, Matrix{T2}}} where {T1&lt;:Real, T2&lt;:Real}" href="#ImagePhaseCongruency.gaussianangularfilter-Union{Tuple{T2}, Tuple{T1}, Tuple{Real, Real, Matrix{T1}, Matrix{T2}}} where {T1&lt;:Real, T2&lt;:Real}"><code>ImagePhaseCongruency.gaussianangularfilter</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Orientation selective frequency domain filter with Gaussian windowing function.</p><pre><code class="nohighlight hljs">Usage: filter = gaussianangularfilter(angl, thetaSigma, sintheta, costheta)

Arguments:
               angl - Orientation of the filter (radians)
         thetasigma - Standard deviation of angular Gaussian window function.
 sintheta, costheta - Grids as returned by gridangles()</code></pre><p>See also: <a href="#ImagePhaseCongruency.cosineangularfilter-Union{Tuple{T2}, Tuple{T1}, Tuple{Real, Real, Matrix{T1}, Matrix{T2}}} where {T1&lt;:Real, T2&lt;:Real}"><code>cosineangularfilter</code></a>, <a href="#ImagePhaseCongruency.gridangles-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{Matrix{T1}, Matrix{T2}, Matrix{T3}}} where {T1&lt;:Real, T2&lt;:Real, T3&lt;:Real}"><code>gridangles</code></a>, <a href="#ImagePhaseCongruency.filtergrids-Tuple{Integer, Integer}"><code>filtergrids</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/frequencyfilt.jl#L483-L496">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.perfft2-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real" href="#ImagePhaseCongruency.perfft2-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real"><code>ImagePhaseCongruency.perfft2</code></a> — <span class="docstring-category">Method</span></header><section><div><p>2D Fourier transform of Moisan&#39;s periodic image component.</p><pre><code class="nohighlight hljs">Usage: (P, S, p, s) = perfft2(img)

Argument: img - Image to be transformed
Returns:    P - 2D fft of periodic image component
            S - 2D fft of smooth component
            p - Periodic component (spatial domain)
            s - Smooth component (spatial domain)</code></pre><p>Moisan&#39;s &quot;Periodic plus Smooth Image Decomposition&quot; decomposes an image into two components</p><pre><code class="nohighlight hljs">    img = p + s</code></pre><p>where s is the &#39;smooth&#39; component with mean 0 and p is the &#39;periodic&#39; component which has no sharp discontinuities when one moves cyclically across the image boundaries.</p><p>This decomposition is very useful when one wants to obtain an FFT of an image with minimal artifacts introduced from the boundary discontinuities.  The image p gathers most of the image information but avoids periodization artifacts.</p><p>The typical use of this function is to obtain a &#39;periodic only&#39; fft of an image</p><pre><code class="nohighlight hljs">  P = perfft2(img)</code></pre><p>Displaying the amplitude spectrum of P will yield a clean spectrum without the typical vertical-horizontal &#39;cross&#39; arising from the image boundaries that you would normally see.</p><p>Note if you are using the function to perform filtering in the frequency domain you may want to retain s (the smooth component in the spatial domain) and add it back to the filtered result at the end.</p><p>The computational cost of obtaining the &#39;periodic only&#39; FFT involves taking an additional FFT.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/frequencyfilt.jl#L648-L688">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.geoseries-Tuple{Real, Real, Integer}" href="#ImagePhaseCongruency.geoseries-Tuple{Real, Real, Integer}"><code>ImagePhaseCongruency.geoseries</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Generate geometric series.</p><p>Useful for generating geometrically scaled wavelengths for specifying filter banks.</p><pre><code class="nohighlight hljs">Usage 1: s = geoseries(s1, mult, n)

Arguments:      s1 - The starting value in the series.
              mult - The scaling factor between succesive values.
                 n - The desired number of elements in the series.

Usage 2: s = geoseries((s1, sn), n)

Arguments: (s1, sn) - Tuple specifying the 1st and last values
                      in the the series.
                  n - The desired number of elements in the series.</code></pre><p>Example:</p><pre><code class="nohighlight hljs">      s = geoseries(0.5, 2, 4)
      s =  [0.5000,    1.0000,    2.0000,    4.0000]</code></pre><p>Alternatively obtain the same series using</p><pre><code class="nohighlight hljs">           s = geoseries((0.5, 4), 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/frequencyfilt.jl#L737-L766">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.step2line" href="#ImagePhaseCongruency.step2line"><code>ImagePhaseCongruency.step2line</code></a> — <span class="docstring-category">Function</span></header><section><div><p>A phase congruent test image that interpolates from a step to a line.</p><p>Generates a test image where the feature type changes from a step edge to a line feature from top to bottom.  Gradient based edge detectors will only correctly mark the step-like feature towards the top of the image and incorrectly mark two features towards the bottom of the image whereas phase congruency will correctly mark a single feature from top to bottom.  In general, natural images contain a roughly uniform distribution of the full continuum of feature types from step to line.</p><pre><code class="nohighlight hljs">Usage:
    img = step2line(sze; nscales=50, ampexponent=-1, ncycles=1.5, phasecycles=0.25)

Arguments:
      sze::Integer - Number of rows in test image, defaults to 512.

Keyword Arguments:
  nscales::Integer - No of Fourier components used to construct the signal.
                     Defaults to 50.
 ampexponent::Real - Decay exponent of amplitude with frequency.
                     A value of -1 will produce amplitude inversely
                     proportional to frequency (corresponds to step feature).
                     A value of -2 will result in the line feature
                     appearing as a triangular waveform. Defaults to -1.
     ncycles::Real - Number of wave cycles across the width of the image.
                     Defaults to 1.5
 phasecycles::Real - Number of feature type phase cycles going vertically
                     down the image. Defaults to 0.25 giving a sequence of feature
                     phase congruency angle varying from 0 to pi/2.
Returns:
   img::Array{Float64,2} - The test image.


Examples of use:
  &gt; img = step2line()                              # Default pattern
  &gt; img = step2line(ncycles=3, ampexponent=-1.5);  # 3 cycles, &#39;soft&#39; step to line
  &gt; img = step2line(ncycles=3, ampexponent=-1.5, phasecycles = 3);
</code></pre><p>See also:  <a href="#ImagePhaseCongruency.circsine"><code>circsine</code></a>, <a href="#ImagePhaseCongruency.starsine"><code>starsine</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/syntheticimages.jl#L44-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.circsine" href="#ImagePhaseCongruency.circsine"><code>ImagePhaseCongruency.circsine</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Generate a phase congruent circular sine wave grating.</p><p>Useful for testing the isotropy of response of a feature dectector.</p><pre><code class="nohighlight hljs">Usage:    img = circsine(sze; wavelength = 40, nscales = 50, ampexponent = -1,
                          offset = 0, p = 2, trim = false)

Arguments:
   sze::Integer  - The size of the square image to be produced. Defaults to 512.

Keyword arguments:
 wavelength::Real - The wavelength in pixels of the sine wave. Defaults to 40.
 nscales::Integer - No of Fourier components used to construct the
                    signal. This is typically 1, if you want a simple sine
                    wave, or &gt;50 if you want to build a phase congruent
                    waveform. Defaults to 50.
ampexponent::Real - Decay exponent of amplitude with frequency.
                    A value of -1 will produce amplitude inversely
                    proportional to frequency (this will produce a step
                    feature if offset is 0)
                    A value of -2 with an offset of pi/2 will result in a
                    triangular waveform.  Defaults to -1;
     offset::Real - Angle of phase congruency at which the features of the
                    star pattern will be generated at. This controls the feature type.
                    0 for a step-like feature, pi/2 for a line/triangular-like feature.
                    Defaults to 0. If nscales = 1 use pi/2 to get continuity
                    at the centre.
      p::Integer  - Optional parameter specifying the norm to use in
                    calculating the radius from the centre. This defaults to
                    2, resulting in a circular pattern.  Large values gives
                    a square pattern
      trim::Bool  - Optional boolean flag indicating whether you want the
                    circular pattern trimmed from the corners leaving
                    only complete circles. Defaults to false.
Returns:
   img::Array{Float64,2} - The test image.

Examples:
&gt; circsine(nscales = 1) - A simple circular sine wave pattern
&gt; circsine(nscales = 50, ampexponent = -1, offset =  0)     - Square waveform
&gt; circsine(nscales = 50, ampexponent = -2, offset = pi/2)   - Triangular waveform
&gt; circsine(nscales = 50, ampexponent = -1.5, offset = pi/4) - Something in between
                                                              square and triangular
&gt; circsine(nscales = 50, ampexponent = -1.5, offset = 0)    - Looks like a square but is not.</code></pre><p>See also: <a href="#ImagePhaseCongruency.starsine"><code>starsine</code></a>, <a href="#ImagePhaseCongruency.step2line"><code>step2line</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/syntheticimages.jl#L123-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.starsine" href="#ImagePhaseCongruency.starsine"><code>ImagePhaseCongruency.starsine</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Generate a phase congruent star shaped sine wave grating.</p><p>Useful for testing the behaviour of feature detectors at line junctions.</p><pre><code class="nohighlight hljs">Usage:    img = starsine(sze; ncycles=10, nscales=50, ampexponent=-1, offset=0)

Argument:
     sze::Integer - The size of the square image to be produced. Defaults to 512.

Keyword arguments:
    ncycles::Real - The number of sine wave cycles around centre point.
                    Typically an integer, but any value can be used.
 nscales::Integer - No of fourier components used to construct the
                    signal. This is typically 1, if you want a simple sine
                    wave, or &gt;50 if you want to build a phase congruent
                    waveform.  Defaults to 50.
ampexponent::Real - Decay exponent of amplitude with frequency.
                    A value of -1 will produce amplitude inversely
                    proportional to frequency (this will produce a step
                    feature if offset is 0)
                    A value of -2 with an offset of pi/2 will result in a
                    triangular waveform.
     offset::Real - Angle of phase congruency at which the features of the
                    star pattern will be generated at. This controls the feature type.
                    0 for a step-like feature, pi/2 for a line/triangular-like feature.
Returns:
   img::Array{Float64,2} - The test image.

Examples:
&gt; starsine(nscales = 1) - A simple sine wave pattern radiating out
                          from the centre. Use &#39;offset&#39; if you wish to
                          rotate it a bit.
&gt; starsine(nscales = 50, ampexponent = -1, offset =  0)     - Square waveform
&gt; starsine(nscales = 50, ampexponent = -2, offset = pi/2)   - Triangular waveform
&gt; starsine(nscales = 50, ampexponent = -1.5, offset = pi/4) - Something in between
                                                              square and triangular
&gt; starsine(nscales = 50, ampexponent = -1.5, offset = 0)    - Looks like a square but is not.</code></pre><p>See also: <a href="#ImagePhaseCongruency.circsine"><code>circsine</code></a>, <a href="#ImagePhaseCongruency.step2line"><code>step2line</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/syntheticimages.jl#L209-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.noiseonf-Tuple{Tuple{Integer, Integer}, Real}" href="#ImagePhaseCongruency.noiseonf-Tuple{Tuple{Integer, Integer}, Real}"><code>ImagePhaseCongruency.noiseonf</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Create <span>$1/f^p$</span> spectrum noise images.</p><p>When displayed as a surface these images also generate great landscape terrain.</p><pre><code class="nohighlight hljs">Usage: img = noiseonf(sze, p)

Arguments:
    sze::Tuple{Integer, Integer} or ::Integer
              - A tuple (rows, cols) or single value specifying size of
                image to produce.
      p::Real - Exponent of spectrum decay = 1/(f^p)

Returns:
   img::Array{Float64,2} - The noise image with specified spectrum.


Reference values for p:
            p = 0   - raw Gaussian noise image.
              = 1   - gives the supposedly 1/f &#39;standard&#39; drop-off for
                      &#39;natural&#39; images.
              = 1.5 - seems to give the most interesting &#39;cloud patterns&#39;.
              = &gt; 2 - produces &#39;blobby&#39; images.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/syntheticimages.jl#L278-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.nophase-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Real" href="#ImagePhaseCongruency.nophase-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Real"><code>ImagePhaseCongruency.nophase</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Randomize image phase leaving amplitude spectrum unchanged.</p><pre><code class="nohighlight hljs">Usage:   newimg = nophase(img)

Argument:       img::AbstractArray{T,2} where T &lt;: Real - Input image

Returns:     newimg::Array{Float64,2} - Image with randomized phase</code></pre><p>In general most images will be destroyed by this transform.  However, some textures are reproduced in an &#39;amplitude only&#39; image quite well.  Typically these are textures which have an amplitude spectrum that have a limited number of isolated peaks. That is, a texture made up from a limited number of strong harmonics.</p><p>See also: <a href="#ImagePhaseCongruency.noiseonf-Tuple{Tuple{Integer, Integer}, Real}"><code>noiseonf</code></a>, <a href="#ImagePhaseCongruency.quantizephase-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Integer}} where T&lt;:Real"><code>quantizephase</code></a>, <a href="#ImagePhaseCongruency.swapphase-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}}} where T&lt;:Real"><code>swapphase</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/syntheticimages.jl#L335-L351">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.quantizephase-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Integer}} where T&lt;:Real" href="#ImagePhaseCongruency.quantizephase-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Integer}} where T&lt;:Real"><code>ImagePhaseCongruency.quantizephase</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Quantize phase values in an image.</p><pre><code class="nohighlight hljs">Usage:  qimg = quantizephase(img, N)

Arguments: img::Array{T,2} where T &lt;: Real - Image to be processed
                     N::Integer - Desired number of quantized phase values

Returns:  qimg::Array{Float64,2} - Phase quantized image</code></pre><p>Phase values in an image are important.  However, despite this, they can be quantized very heavily with little perceptual loss.  The value of N can be as low as 4, or even 3!  Using N = 2 is also worth a look.</p><p>See also: <a href="#ImagePhaseCongruency.swapphase-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}}} where T&lt;:Real"><code>swapphase</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/syntheticimages.jl#L374-L389">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.swapphase-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}}} where T&lt;:Real" href="#ImagePhaseCongruency.swapphase-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}}} where T&lt;:Real"><code>ImagePhaseCongruency.swapphase</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Demonstrates phase - amplitude swapping between images.</p><pre><code class="nohighlight hljs">Usage:   (newimg1, newimg2) = swapphase(img1, img2)

Arguments:
 img1, img2::Array{&lt;:Real,2} - Two images of same size to be used as input

Returns:
    newimg1::Array{Float64,2} - Image obtained from the phase of img1
                                and the magnitude of img2.
    newimg2::Array{Float64,2} - Phase of img2, magnitude of img1.</code></pre><p>See also: <a href="#ImagePhaseCongruency.quantizephase-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Integer}} where T&lt;:Real"><code>quantizephase</code></a>, <a href="#ImagePhaseCongruency.nophase-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Real"><code>nophase</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/syntheticimages.jl#L415-L430">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.fillnan-Union{Tuple{AbstractArray{T, N}}, Tuple{T}, Tuple{N}} where {N, T}" href="#ImagePhaseCongruency.fillnan-Union{Tuple{AbstractArray{T, N}}, Tuple{T}, Tuple{N}} where {N, T}"><code>ImagePhaseCongruency.fillnan</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Fill NaN values in an image with closest non NaN value.</p><p>This can be used as a crude (but quick) &#39;inpainting&#39; function to allow a FFT to be computed on an image containing NaN values.  While the &#39;inpainting&#39; is crude it is typically good enough to remove most of the edge effects one might get at the boundaries of the NaN regions.  The NaN regions should then be remasked out of the final processed image.</p><pre><code class="nohighlight hljs">Usage:  (newim, mask) = fillnan(img)

  Argument:  img   - Image to be &#39;filled&#39;.
  Returns:   newim - Filled image.
             mask  - Binary image indicating the valid, non-NaN, regions in
                     the original image.</code></pre><p>See also: <a href="#ImagePhaseCongruency.replacenan-Union{Tuple{AbstractArray{T, N}}, Tuple{T}, Tuple{N}, Tuple{AbstractArray{T, N}, Real}} where {N, T&lt;:AbstractFloat}"><code>replacenan</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/utilities.jl#L32-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.replacenan-Union{Tuple{AbstractArray{T, N}}, Tuple{T}, Tuple{N}, Tuple{AbstractArray{T, N}, Real}} where {N, T&lt;:AbstractFloat}" href="#ImagePhaseCongruency.replacenan-Union{Tuple{AbstractArray{T, N}}, Tuple{T}, Tuple{N}, Tuple{AbstractArray{T, N}, Real}} where {N, T&lt;:AbstractFloat}"><code>ImagePhaseCongruency.replacenan</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Replace NaNs in an array with a specified value.</p><pre><code class="nohighlight hljs">Usage: (newimg, mask) = replacenan(img, defaultval=0)

Arguments:
   img        - The Array containing NaN values.
   defaultval - The default value to replace NaNs.

Returns:
        newim - Filled image,
        mask  - Boolean image indicating non-NaN regions in the original
                image.</code></pre><p>See also: <a href="#ImagePhaseCongruency.fillnan-Union{Tuple{AbstractArray{T, N}}, Tuple{T}, Tuple{N}} where {N, T}"><code>fillnan</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/utilities.jl#L75-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImagePhaseCongruency.hysthresh-Union{Tuple{T0}, Tuple{AbstractMatrix{T0}, Real, Real}} where T0&lt;:Real" href="#ImagePhaseCongruency.hysthresh-Union{Tuple{T0}, Tuple{AbstractMatrix{T0}, Real, Real}} where T0&lt;:Real"><code>ImagePhaseCongruency.hysthresh</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Hysteresis thresholding of an image.</p><pre><code class="nohighlight hljs">Usage: bw = hysthresh(img, T1, T2)

Arguments:
           img  - Image to be thresholded
        T1, T2  - Upper and lower threshold values.  T1 and T2
                  can be entered in any order, the larger of the
                  two values is used as the upper threshold.
Returns:
            bw  - The binary thresholded image as a BitArray</code></pre><p>All pixels with values above threshold T1 are marked as edges. All pixels that are connected to points that have been marked as edges and with values above threshold T2 are also marked as edges. Eight connectivity is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/peterkovesi/ImagePhaseCongruency.jl/blob/119afbfe78f41afd47ea9d022f877b6868dc6b25/src/utilities.jl#L100-L117">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Examples</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 25 November 2021 09:53">Thursday 25 November 2021</span>. Using Julia version 1.6.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
